using System.Collections.Generic;

namespace Localization.Editor
{
	//TODO: доделать как будет время, нужно генерировать LocKeys и LocTags, LocTags генерировать аддитивно, без перезаписи
	//TODO: можеть сделать какой-то ConstantsGenerator, пока не знаю
	public static class LocalizationConstantsGenerator
	{
		private static readonly string[] ABBREVIATIONS = {"UI", "VFX", "FX", "HUD", "IAP"};

		private const string NAMESPACE_COMMENT = "// <auto-generated/>";
		private const string LOC_KEYS_NAME = "LocKeys";
		private const string LOCALIZATION_NAME = "Localization";
		private const string NEW_LINE_TAG = "{NEW_LINE}";
		private const string DEFAULT_PATH = "Assets/Scripts/" + LOCALIZATION_NAME + "/";
		private const string ROOT_NODE = "ROOT";
		private const string GENERATED_PREFIX_LOG = "Generated";

		/*

		internal static void Generate(List<string> keys)
		{
			if (keys == null || keys.Count == 0)
				return;

			var rootPath = DEFAULT_PATH;
			var rootName = nameof(Localization);

			var guid = AssetDatabase.FindAssets($"t:asmdef {rootName}")
			   .FirstOrDefault(x => AssetDatabase.GUIDToAssetPath(x).Contains($"{rootName}/{rootName}.asmdef"));

			if (!guid.IsNullOrEmpty())
			{
				var asmdefPath = AssetDatabase.GUIDToAssetPath(guid);
				var asmdefDirectoryInfo = new DirectoryInfo(Path.GetDirectoryName(asmdefPath) ?? string.Empty);
				var constantsDirectoryInfo = new DirectoryInfo(Path.Combine(asmdefDirectoryInfo.FullName, LOCALIZATION_NAME));
				if (!constantsDirectoryInfo.Exists)
					constantsDirectoryInfo.Create();

				rootPath = constantsDirectoryInfo.FullName;

				var asmdefFileInfo = new FileInfo(Path.Combine(constantsDirectoryInfo.FullName, $"{rootName}.{LOCALIZATION_NAME}.asmdef"));
				if (!asmdefFileInfo.Exists)
				{
					var constantsAsmdefPath = asmdefFileInfo.FullName;
					var text = $@"
					{{
						""name"": ""{rootName}.{LOCALIZATION_NAME}"",
						""rootNamespace"": """",
						""references"": [],
						""includePlatforms"": [],
						""excludePlatforms"": [],
						""allowUnsafeCode"": false,
						""overrideReferences"": false,
						""precompiledReferences"": [],
						""autoReferenced"": true,
						""defineConstraints"": [],
						""versionDefines"": [],
						""noEngineReferences"": true
					}}";

					File.WriteAllText(constantsAsmdefPath, text);
					AssetDatabase.ImportAsset(constantsAsmdefPath);
					var asmdefAsset = AssetDatabase.LoadAssetAtPath<TextAsset>(constantsAsmdefPath);
					LocalizationDebug.Log($"{GENERATED_PREFIX_LOG} .asmdef: {constantsAsmdefPath}", asmdefAsset);
				}
			}

			if (!Directory.Exists(rootPath))
				Directory.CreateDirectory(rootPath);

			var fileName = $"{LOC_KEYS_NAME}.Generated.cs";
			var path = Path.Combine(fullPath, fileName);

			var existingData = File.Exists(path) ? File.ReadAllText(path) : null;

			var root = new GeneratorConstantsNode {name = ROOT_NODE};

			foreach (var source in keys)
			{
				var id = source.Id;

				if (attribute?.FilterOut != null && attribute.FilterOut.Any(target => id.Contains(target)))
					continue;

				var parts = id.Split('/');
				var current = root;
				foreach (var part in parts)
				{
					if (!current.children.ContainsKey(part))
						current.children[part] = new GeneratorConstantsNode {name = part};
					current = current.children[part];
				}

				current.fullPath = id;
			}

			var compilationUnit = SyntaxFactory.CompilationUnit();

			var namespaceName = !string.IsNullOrEmpty(type.Namespace)
				? $"{rootName}.{LOCALIZATION_NAME}.{type.Namespace}"
				: $"{rootName}.{LOCALIZATION_NAME}";

			var namespaceDeclaration = SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName(namespaceName))
			   .NormalizeWhitespace()
			   .WithLeadingTrivia(SyntaxFactory.Comment(NAMESPACE_COMMENT));

			var classDeclaration = SyntaxFactory.ClassDeclaration(className)
			   .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.StaticKeyword));

			void AddConstants(GeneratorConstantsNode node, List<string> pathSegments, ref bool needSpace)
			{
				var hasAnyLeaves = node.children.Values.Any(HasLeaf);

				var currentPath = new List<string>(pathSegments) {node.name};
				var comment = string.Join(" -> ", currentPath.Skip(1));

				var commented = false;

				foreach (var child in node.children.Values.OrderBy(c => c.name))
				{
					if (child.children.Count != 0 || child.fullPath == null)
						continue;

					var constName = GetName(child.fullPath);
					var fieldDeclaration = SyntaxFactory.FieldDeclaration(
							SyntaxFactory.VariableDeclaration(
									SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.StringKeyword)))
							   .AddVariables(
									SyntaxFactory.VariableDeclarator(constName)
									   .WithInitializer(
											SyntaxFactory.EqualsValueClause(
												SyntaxFactory.LiteralExpression(
													SyntaxKind.StringLiteralExpression,
													SyntaxFactory.Literal(child.fullPath))))))
					   .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.ConstKeyword));

					using (ListPool<SyntaxTrivia>.Get(out var trivia))
					{
						if (!commented && !string.IsNullOrEmpty(comment) && hasAnyLeaves && pathSegments.Count > 0)
						{
							if (needSpace)
								trivia.Add(SyntaxFactory.Comment(NEW_LINE_TAG));

							trivia.Add(SyntaxFactory.Comment($"// {comment}"));

							needSpace = false;
							commented = true;
						}

						fieldDeclaration = fieldDeclaration.WithLeadingTrivia(trivia);
					}

					classDeclaration = classDeclaration.AddMembers(fieldDeclaration);

					needSpace = true;
				}

				foreach (var child in node.children.Values.OrderBy(c => c.name))
				{
					if (child.children.Count > 0)
						AddConstants(child, currentPath, ref needSpace);
				}
			}

			var needSpace = false;
			AddConstants(root, new List<string>(), ref needSpace);

			namespaceDeclaration = namespaceDeclaration.AddMembers(classDeclaration);
			compilationUnit = compilationUnit.AddMembers(namespaceDeclaration);

			var code = compilationUnit
			   .NormalizeWhitespace(indentation: "	")
			   .ToFullString();
			code = code.Replace(NEW_LINE_TAG, string.Empty);

			if (existingData == code)
				return;

			File.WriteAllText(path, code);
			AssetDatabase.ImportAsset(path);

			var textAsset = AssetDatabase.LoadAssetAtPath<TextAsset>(path);
			var prefix = existingData == null ? GENERATED_PREFIX_LOG : "Updated";
			LocalizationDebug.Log($"{prefix} constants: {path}", textAsset);

			bool HasLeaf(GeneratorConstantsNode c)
			{
				if (c.fullPath != null)
					return true;

				return c.children.Values.Any(HasLeaf);
			}

			string GetName(string input)
			{
				if (string.IsNullOrEmpty(input))
					return string.Empty;

				var sb = new StringBuilder();

				foreach (var prefix in ABBREVIATIONS)
				{
					if (input.StartsWith(prefix) && input.Length > prefix.Length && char.IsUpper(input[prefix.Length]))
					{
						sb.Append(prefix);
						sb.Append('_');
						input = input[prefix.Length..];
						break;
					}
				}

				for (int i = 0; i < input.Length; i++)
				{
					char current = input[i];
					char? next = i + 1 < input.Length ? input[i + 1] : (char?) null;

					if (char.IsUpper(current))
					{
						if (i > 0 && (char.IsLower(input[i - 1]) || (next.HasValue && char.IsLower(next.Value))))
							sb.Append('_');
						sb.Append(current);
					}
					else
					{
						sb.Append(char.ToUpper(current));
					}
				}

				return sb.ToString().Replace("/", string.Empty);
			}
		}

		*/
	}

	internal class GeneratorConstantsNode
	{
		public string name;
		public Dictionary<string, GeneratorConstantsNode> children = new();
		public string fullPath; //id
	}
}
